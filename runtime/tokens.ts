/**
 * Token values for Lexer
 */

export const enum Token {
    NIL = 0,
    EOF,
    ERROR,
    IDENTIFIER,
    NUMBER,
    STRING,
    WHITESPACE,
    COMMENT,
    NEWLINE,
    // operators and punctuation
    HASH,
    COMMA,
    COLON,
    SEMICOLON,
    Q_MARK,
    AT,
    DOT,
    L_PAREN,
    R_PAREN,
    L_BRACKET,
    R_BRACKET,
    L_CURLY,
    R_CURLY,
    IS,
    ISNT,
    MATCH,
    MATCHNOT,
    LT,
    LTE,
    GT,
    GTE,
    ADD,
    SUB,
    CAT,
    MUL,
    DIV,
    MOD,
    LSHIFT,
    RSHIFT,
    BITOR,
    BITAND,
    BITXOR,
    NOT,
    INC,
    DEC,
    BITNOT,
    EQ,
    ADDEQ,
    SUBEQ,
    CATEQ,
    MULEQ,
    DIVEQ,
    MODEQ,
    LSHIFTEQ,
    RSHIFTEQ,
    BITOREQ,
    BITANDEQ,
    BITXOREQ,
    RANGETO,
    RANGELEN,
    // langauge keywords
    AND,
    BOOL,
    BREAK,
    BUFFER,
    CALLBACK,
    CASE,
    CATCH,
    CHAR,
    CLASS,
    CONTINUE,
    CREATE,
    DEFAULT,
    DLL,
    DO,
    DOUBLE,
    ELSE,
    FALSE,
    FLOAT,
    FOR,
    FOREVER,
    FUNCTION,
    GDIOBJ,
    HANDLE,
    IF,
    IN,
    INT64,
    LONG,
    NEW,
    OR,
    RESOURCE,
    RETURN,
    SHORT,
    STRUCT,
    SWITCH,
    SUPER,
    THIS,
    THROW,
    TRUE,
    TRY,
    VOID,
    WHILE,
    // query keywords
    ALTER,
    AVERAGE,
    CASCADE,
    COUNT,
    DELETE,
    DROP,
    ENSURE,
    EXTEND,
    HISTORY,
    INDEX,
    INSERT,
    INTERSECT,
    INTO,
    JOIN,
    KEY,
    LEFTJOIN,
    LIST,
    MAX,
    MIN,
    MINUS,
    PROJECT,
    REMOVE,
    RENAME,
    REVERSE,
    SET,
    SORT,
    SUMMARIZE,
    SVIEW,
    TIMES,
    TO,
    TOTAL,
    UNION,
    UNIQUE,
    UPDATE,
    UPDATES,
    VIEW,
    WHERE
}

// needed this to avoid error in lexer.ts from tsc
// may be able to remove in future
interface StrToTok {
    [key: string]: Token;
}

export const keywords: StrToTok = {
    "and": Token.AND,
    "bool": Token.BOOL,
    "break": Token.BREAK,
    "buffer": Token.BUFFER,
    "callback": Token.CALLBACK,
    "case": Token.CASE,
    "catch": Token.CATCH,
    "char": Token.CHAR,
    "class": Token.CLASS,
    "continue": Token.CONTINUE,
    "default": Token.DEFAULT,
    "dll": Token.DLL,
    "do": Token.DO,
    "double": Token.DOUBLE,
    "else": Token.ELSE,
    "false": Token.FALSE,
    "float": Token.FLOAT,
    "for": Token.FOR,
    "forever": Token.FOREVER,
    "function": Token.FUNCTION,
    "gdiobj": Token.GDIOBJ,
    "handle": Token.HANDLE,
    "if": Token.IF,
    "in": Token.IN,
    "int64": Token.INT64,
    "is": Token.IS,
    "isnt": Token.ISNT,
    "long": Token.LONG,
    "new": Token.NEW,
    "not": Token.NOT,
    "or": Token.OR,
    "resource": Token.RESOURCE,
    "return": Token.RETURN,
    "short": Token.SHORT,
    "string": Token.STRING,
    "struct": Token.STRUCT,
    "super": Token.SUPER,
    "switch": Token.SWITCH,
    "this": Token.THIS,
    "throw": Token.THROW,
    "true": Token.TRUE,
    "try": Token.TRY,
    "void": Token.VOID,
    "while": Token.WHILE,
    "xor": Token.ISNT,
};
